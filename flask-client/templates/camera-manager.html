{% extends "base.html" %}

{% block title %}Belt Vision - Camera Manager{% endblock %}
{% block nav_camera %}active{% endblock %}

{% block content %}
<h1>Connected Devices</h1>
        <table border="1">
            <thead>
                <tr>
                    <th>Type</th>
                    <th>ID</th>
                    <th>Info</th>
                    <th>IP Address</th>
                    <th>Status</th>
                    <th>ML Model</th>
                    <th>Classifier</th>
                    <th>Thread Control</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody id="deviceTableBody">
            </tbody>
        </table>
        <button id="refreshBtn">Refresh</button>

        <div id="videoContainer" style="display:none; margin-top:20px;">
            <h2>Video Feed</h2>
            <img id="videoFeed" width="640" alt="Video feed will appear here">
        </div>
{% endblock %}

{% block additional_scripts %}
<script>
    // Initialize global variables
    window.models = {{ models|tojson }};
    window.classifiers = {{ classifiers|tojson }};
    
    // Load devices function
    async function loadDevices() {
        console.log('=== REFRESH CLICKED ==='); // Debug log
        const tableBody = document.getElementById('deviceTableBody');
        
        try {
            // Fetch devices with timeout
            console.log('Fetching connected devices...');
            const controller1 = new AbortController();
            const timeout1 = setTimeout(() => controller1.abort(), 5000); // 5 second timeout
            
            const response = await fetch('/connected-devices', { signal: controller1.signal });
            clearTimeout(timeout1);
            
            if (!response.ok) {
                console.error('Failed to fetch devices:', response.status);
                tableBody.innerHTML = '<tr><td colspan="9">Error loading devices</td></tr>';
                return;
            }
            const devices = await response.json();
            console.log('✓ Devices loaded:', devices.length);
            
            // Get active threads with timeout
            console.log('Fetching active threads...');
            const controller2 = new AbortController();
            const timeout2 = setTimeout(() => controller2.abort(), 5000);
            
            const threadsResponse = await fetch('/active-threads', { signal: controller2.signal });
            clearTimeout(timeout2);
            
            if (!threadsResponse.ok) {
                console.error('Failed to fetch active threads:', threadsResponse.status);
                // Continue anyway with no thread info
            }
            const activeThreads = await threadsResponse.json();
            console.log('✓ Active threads loaded:', activeThreads.length);
            
            // Create a map of active thread IDs
            const activeThreadsMap = new Map();
            activeThreads.forEach(thread => {
                activeThreadsMap.set(thread.thread_id, thread);
            });
            
            // Clear table
            tableBody.innerHTML = '';
            
            // Get defaults from localStorage
            const defaultModel = localStorage.getItem('defaultModel') || '';
            const defaultClassifier = localStorage.getItem('defaultClassifier') || '';
            
            // Build table rows
            devices.forEach(device => {
                const row = document.createElement('tr');
                
                // Build model select
                let modelOptions = '<option value="">Select Model</option>';
                window.models.forEach(model => {
                    const modelId = `${model[1]}:${model[2]}`;
                    const selected = modelId === defaultModel ? 'selected' : '';
                    modelOptions += `<option value="${modelId}" ${selected}>${model[1]} (${model[2]})</option>`;
                });
                const modelSelect = `<select>${modelOptions}</select>`;
                
                // Build classifier select
                let classifierOptions = '<option value="">Select Classifier</option>';
                window.classifiers.forEach(classifier => {
                    const classifierId = `${classifier[1]}:${classifier[2]}`;
                    const selected = classifierId === defaultClassifier ? 'selected' : '';
                    classifierOptions += `<option value="${classifierId}" ${selected}>${classifier[1]} (${classifier[2]})</option>`;
                });
                const classifierSelect = `<select>${classifierOptions}</select>`;
                
                // Check if this device has an active thread
                const threadId = `${device.type}_${device.id}`;
                const threadInfo = activeThreadsMap.get(threadId);
                const isThreadRunning = threadInfo && threadInfo.running;
                const threadButtonText = isThreadRunning ? 'Stop Thread' : 'Start Thread';
                const threadButtonColor = isThreadRunning ? 'background-color: #ff4444;' : '';
                
                row.innerHTML = `
                    <td>${device.type}</td>
                    <td>${device.id}</td>
                    <td>${device.info}</td>
                    <td>${device.ip}</td>
                    <td>${device.status}</td>
                    <td>${modelSelect}</td>
                    <td>${classifierSelect}</td>
                    <td><button class="thread-btn" data-thread-id="${device.type}_${device.id}" onclick="toggleThread('${device.type}', ${device.id}, this)" style="${threadButtonColor}">${threadButtonText}</button></td>
                    <td><button onclick="viewStream('${device.type}', ${device.id}, this)">View Stream</button></td>
                `;
                tableBody.appendChild(row);
            });
            
            console.log('✓ Table updated successfully');
        } catch (error) {
            if (error.name === 'AbortError') {
                console.error('Request timeout - servers may be offline');
                tableBody.innerHTML = '<tr><td colspan="9">Request timeout - check if servers are running</td></tr>';
            } else {
                console.error('Error loading devices:', error);
                tableBody.innerHTML = '<tr><td colspan="9">Error: ' + error.message + '</td></tr>';
            }
        }
    }
    
    function viewStream(type, id, btn) {
        const videoContainer = document.getElementById('videoContainer');
        const videoFeed = document.getElementById('videoFeed');
        
        // Check if video is currently playing
        if (btn.textContent === 'Stop Stream') {
            // Stop the stream
            videoFeed.src = '';
            videoContainer.style.display = 'none';
            btn.textContent = 'View Stream';
            btn.style.backgroundColor = '';
            
            // Reset all other view stream buttons
            document.querySelectorAll('button').forEach(b => {
                if (b.textContent === 'Stop Stream' && b !== btn) {
                    b.textContent = 'View Stream';
                    b.style.backgroundColor = '';
                }
            });
        } else {
            // Start the stream
            const row = btn.closest('tr');
            const selects = row.querySelectorAll('select');
            const modelValue = selects[0].value;
            const classifierValue = selects[1].value;
            let url;
            if (type === 'legacy') {
                url = `/legacy-camera-video/${id}`;
            } else if (type === 'simulator') {
                url = '/simulator-video';
            } else {
                url = '/video';
            }
            const params = [];
            if (modelValue) params.push(`model=${encodeURIComponent(modelValue)}`);
            if (classifierValue) params.push(`classifier=${encodeURIComponent(classifierValue)}`);
            if (params.length) url += '?' + params.join('&');
            
            // Reset all other view stream buttons
            document.querySelectorAll('button').forEach(b => {
                if (b.textContent === 'Stop Stream') {
                    b.textContent = 'View Stream';
                    b.style.backgroundColor = '';
                }
            });
            
            videoFeed.src = url;
            videoContainer.style.display = 'block';
            btn.textContent = 'Stop Stream';
            btn.style.backgroundColor = '#4444ff';
        }
    }
    
    window.onload = function() {
        console.log('Page loaded, initializing...');
        
        // Attach event listener to refresh button
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
                console.log('Refresh button clicked');
                loadDevices();
            });
        }
        
        // Initial load
        loadDevices();
    };

    async function toggleThread(type, id, btn) {
        const threadId = `${type}_${id}`;
        const row = btn.closest('tr');
        const selects = row.querySelectorAll('select');
        const modelValue = selects[0].value;
        const classifierValue = selects[1].value;
        
        if (btn.textContent === 'Start Thread') {
            // Start thread
            try {
                const response = await fetch('/start-thread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        type: type,
                        id: id,
                        model: modelValue,
                        classifier: classifierValue
                    })
                });
                
                if (response.ok) {
                    btn.textContent = 'Stop Thread';
                    btn.style.backgroundColor = '#ff4444';
                } else {
                    const error = await response.json();
                    alert('Error starting thread: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error starting thread: ' + error);
            }
        } else {
            // Stop thread
            try {
                const response = await fetch('/stop-thread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        thread_id: threadId
                    })
                });
                
                if (response.ok) {
                    btn.textContent = 'Start Thread';
                    btn.style.backgroundColor = '';
                } else {
                    alert('Error stopping thread');
                }
            } catch (error) {
                alert('Error stopping thread: ' + error);
            }
        }
    }

</script>
{% endblock %}